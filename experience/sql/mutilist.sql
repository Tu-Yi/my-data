-- 多表查询

-- 内连接 父级在后面
-- 等值连接
select EMP.LAST_NAME,DEP.DEPARTMENT_NAME from EMPLOYEES EMP,DEPARTMENTS DEP where EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID and EMP.LAST_NAME='Taylor'
SELECT EMP.LAST_NAME,DEP.DEPARTMENT_NAME,LO.CITY FROM EMPLOYEES EMP,DEPARTMENTS DEP,LOCATIONS LO WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID AND DEP.LOCATION_ID = LO.LOCATION_ID and EMP.LAST_NAME='Taylor'
-- 非等值连接 != > < BETWEEN AND
select * from EMPLOYEES EMP,JOB_GRADS GR WHERE EMP.SALARY BETWEEN GR.LOWER AND GR.HIGHER
-- 自连接
select WORKER.LAST_NAME,MANAGER.LAST_NAME from EMPLOYEES WORKER ,EMPLOYEES MANAGER WHERE WORKER.MANAGER_ID = MANAGER.MANAGER_ID
-- CROSS JOIN 笛卡尔乘积
-- NATURAL JOIN 只要列名字和类型相同，就都使用等值连接，取最小笛卡尔乘积
select d.DEPARTMENT_NAME,l.CITY from DEPARTMENTS d NATURAL JOIN LOCATIONS l
-- NATURAL JOIN USING唯一指定等值列 USING中的列在where中不能用表名和别名 USING可以指定多个列
select d.DEPARTMENT_NAME,l.CITY from DEPARTMENTS d JOIN LOCATIONS l USING(LOCATION_ID) WHERE LOCATION_ID=1800
-- INNER JOIN 基本和等值连接一样
SELECT EMP.LAST_NAME,DEP.DEPARTMENT_NAME,LO.CITY FROM 
EMPLOYEES EMP INNER JOIN DEPARTMENTS DEP ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
INNER JOIN LOCATIONS LO ON DEP.LOCATION_ID = LO.LOCATION_ID
WHERE EMP.EMPLOYEE_ID='202'
-- INNER JOIN using等值
SELECT EMP.LAST_NAME,DEP.DEPARTMENT_NAME,LO.CITY FROM 
EMPLOYEES EMP INNER JOIN DEPARTMENTS DEP using(DEPARTMENT_ID)
INNER JOIN LOCATIONS LO USING(LOCATION_ID)
WHERE EMP.EMPLOYEE_ID='202'

-- 外连接 可以显示孤儿数据
select emp.LAST_NAME,dep.DEPARTMENT_NAME from EMPLOYEES emp LEFT JOIN DEPARTMENTS dep on emp.DEPARTMENT_ID=dep.DEPARTMENT_ID
select emp.LAST_NAME,dep.DEPARTMENT_NAME from EMPLOYEES emp FULL JOIN DEPARTMENTS dep on emp.DEPARTMENT_ID=dep.DEPARTMENT_ID
-- oracle扩展的外连接 (+)不显示所有数据
select emp.LAST_NAME,dep.DEPARTMENT_NAME from EMPLOYEES emp， DEPARTMENTS dep  where EMP.DEPARTMENT_ID(+) = DEP.DEPARTMENT_ID
select emp.LAST_NAME,dep.DEPARTMENT_NAME from EMPLOYEES emp， DEPARTMENTS dep  where EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID(+)

-- 练习
select EMP.LAST_NAME, EMP.DEPARTMENT_ID, DEP.DEPARTMENT_NAME from EMPLOYEES EMP,DEPARTMENTS DEP where EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID
select EMP.LAST_NAME, EMP.DEPARTMENT_ID, DEP.DEPARTMENT_NAME from EMPLOYEES EMP INNER JOIN DEPARTMENTS DEP ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID
select DISTINCT EMP.JOB_ID, DEP.LOCATION_ID from EMPLOYEES EMP,DEPARTMENTS DEP WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID and EMP.DEPARTMENT_ID=80
SELECT EMP.LAST_NAME,DEP.DEPARTMENT_NAME,LO.CITY FROM EMPLOYEES EMP,DEPARTMENTS DEP,LOCATIONS LO WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID AND DEP.LOCATION_ID = LO.LOCATION_ID and EMP.COMMISSION_PCT is NOT NULL
select EMP.LAST_NAME, EMP.DEPARTMENT_ID, DEP.DEPARTMENT_NAME from EMPLOYEES EMP,DEPARTMENTS DEP where EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID and EMP.LAST_NAME like '%a%'

SELECT EMP.LAST_NAME,DEP.DEPARTMENT_NAME,LO.CITY FROM 
EMPLOYEES EMP INNER JOIN DEPARTMENTS DEP ON EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID 
INNER JOIN LOCATIONS LO ON DEP.LOCATION_ID = LO.LOCATION_ID
WHERE LOWER(LO.CITY) = 'toronto'

select WORKER.LAST_NAME,MANAGER.LAST_NAME from EMPLOYEES WORKER LEFT OUTER JOIN EMPLOYEES MANAGER ON (WORKER.MANAGER_ID = MANAGER.employee_id)
-- ⭐
SELECT e.LAST_NAME,e.DEPARTMENT_ID FROM EMPLOYEES e, EMPLOYEES c where e.DEPARTMENT_ID = c.DEPARTMENT_ID and e.EMPLOYEE_ID <> c.EMPLOYEE_ID order by c.DEPARTMENT_ID

select e.LAST_NAME,e.HIRE_DATE from EMPLOYEES e, EMPLOYEES d where d.LAST_NAME='Davies' and d.HIRE_DATE<e.HIRE_DATE

select e.LAST_NAME,e.HIRE_DATE,m.LAST_NAME,m.HIRE_DATE from EMPLOYEES e,EMPLOYEES m where e.MANAGER_ID=m.EMPLOYEE_ID and e.HIRE_DATE<m.HIRE_DATE



